"""DXF exporter module - SOLO ESPORTAZIONE DXF.

Questo modulo contiene esclusivamente le funzioni per l'esportazione DXF.
Le funzioni di packing sono state spostate in core/wall_builder.py
Le funzioni di preview immagini sono state spostate in exporters/image_exporter.py
Le utilities dei blocchi sono state spostate in utils/block_utils.py
"""

from __future__ import annotations

import datetime
from typing import Dict, List, Optional

from shapely.geometry import Polygon, shape

try:
    import ezdxf
    from ezdxf import colors as dxf_colors
    from ezdxf.enums import TextEntityAlignment
    EZDXF_AVAILABLE = True
except ImportError:  # pragma: no cover
    ezdxf = None  # type: ignore
    dxf_colors = None  # type: ignore
    TextEntityAlignment = None  # type: ignore
    EZDXF_AVAILABLE = False

from exporters.labels import create_block_labels, create_detailed_block_labels
from utils.file_manager import get_organized_output_path

# Importa dai nuovi moduli per le funzioni di raggruppamento
try:
    from block_grouping import (
        create_grouped_block_labels,
        get_block_category_summary,
        group_blocks_by_category,
        group_custom_blocks_by_category,
    )
    print("[INFO] Modulo block_grouping importato correttamente")
except ImportError:
    print("[WARN] Modulo block_grouping non disponibile, uso sistema legacy")
    create_grouped_block_labels = None
    get_block_category_summary = None
    group_blocks_by_category = None
    group_custom_blocks_by_category = None


__all__ = ["export_to_dxf", "EZDXF_AVAILABLE"]


def export_to_dxf(summary: Dict[str, int], 
                  customs: List[Dict], 
                  placed: List[Dict], 
                  wall_polygon: Polygon,
                  apertures: Optional[List[Polygon]] = None,
                  project_name: str = "Progetto Parete",
                  out_path: str = "schema_taglio.dxf",
                  params: Optional[Dict] = None,
                  color_theme: Optional[Dict] = None,
                  block_config: Optional[Dict] = None) -> str:
    """
    Genera DXF con layout: SOPRA assemblato completo + SOTTO schema taglio raggruppato.
    """
    if not EZDXF_AVAILABLE:
        raise RuntimeError("ezdxf non disponibile. Installa con: pip install ezdxf")
    
    # Usa il sistema di organizzazione automatica
    organized_path = get_organized_output_path(out_path, 'dxf')
    
    try:
        # Crea nuovo documento DXF
        doc = ezdxf.new('R2010')
        msp = doc.modelspace()
        
        # Setup layer professionali
        _setup_dxf_layers(doc, color_theme)
        
        # Calcola bounds wall per reference
        minx, miny, maxx, maxy = wall_polygon.bounds
        wall_width = maxx - minx
        wall_height = maxy - miny
        
        # ===== LAYOUT SEMPLIFICATO: SOPRA + SOTTO =====
        layout = DXFLayoutManager(wall_width, wall_height)
        
        # 1. LAYOUT PRINCIPALE assemblato (zona superiore)
        main_zone = layout.add_zone("main", wall_width, wall_height)
        _draw_main_layout(msp, wall_polygon, placed, customs, apertures, main_zone, block_config)
        
        # 2. SCHEMA TAGLIO raggruppato (zona inferiore con separazione)
        cutting_width = wall_width  # Stessa larghezza del main
        cutting_height = _calculate_cutting_height_grouped_all(summary, customs, placed)
        cutting_zone = layout.add_zone("cutting", cutting_width, cutting_height, 
                                     anchor="below", ref_zone="main", margin=2000)  # Separazione aumentata
        _draw_cutting_schema_fixed(msp, customs, cutting_zone)
        
        # 3. CARTIGLIO compatto (angolo basso destro)
        cartridge_width = 2000
        cartridge_height = 1000
        cartridge_zone = layout.add_zone("cartridge", cartridge_width, cartridge_height,
                                       anchor="below_right", ref_zone="cutting", margin=500)
        _draw_compact_cartridge(msp, project_name, summary, customs, params, cartridge_zone)
        
        # Salva documento
        doc.saveas(organized_path)
        print(f"‚úÖ DXF con layout SOPRA+SOTTO generato: {organized_path}")
        print(f"üìê Layout totale: {layout.get_total_width():.0f} x {layout.get_total_height():.0f} mm")
        return organized_path
        
    except Exception as e:
        print(f"‚ùå Errore generazione DXF: {e}")
        raise


class DXFLayoutManager:
    """Gestisce il layout DXF evitando sovrapposizioni."""
    
    def __init__(self, base_width: float, base_height: float):
        self.zones = {}
        self.base_width = base_width
        self.base_height = base_height
        self.total_bounds = [0, 0, 0, 0]  # minx, miny, maxx, maxy
        
    def add_zone(self, name: str, width: float, height: float, 
                 anchor: str = "topleft", ref_zone: str = None, margin: float = 500) -> Dict:
        """
        Aggiunge una zona calcolando automaticamente la posizione senza sovrapposizioni.
        
        anchor options:
        - "topleft": (0, 0) - default
        - "right_of": a destra della zona ref
        - "below": sotto la zona ref  
        - "below_right": sotto e a destra della zona ref
        - "bottom": in fondo a tutto
        """
        
        if anchor == "topleft" or ref_zone is None:
            # Prima zona o posizione assoluta
            x, y = 0, 0
            
        elif anchor == "right_of" and ref_zone in self.zones:
            ref = self.zones[ref_zone]
            x = ref['x'] + ref['width'] + margin
            y = ref['y']
            
        elif anchor == "below" and ref_zone in self.zones:
            ref = self.zones[ref_zone]
            x = ref['x']
            y = ref['y'] - height - margin
            
        elif anchor == "below_right" and ref_zone in self.zones:
            ref = self.zones[ref_zone]
            x = ref['x'] + ref['width'] - width  # Allineato a destra
            y = ref['y'] - height - margin
            
        elif anchor == "bottom":
            # In fondo rispetto a tutte le zone esistenti
            x = 0
            y = min(zone['y'] - zone['height'] for zone in self.zones.values()) - margin - height
            
        else:
            # Fallback
            x, y = 0, 0
            
        zone = {
            'name': name,
            'x': x,
            'y': y,
            'width': width,
            'height': height,
            'anchor': anchor,
            'ref_zone': ref_zone
        }
        
        self.zones[name] = zone
        self._update_total_bounds(zone)
        
        print(f"üéØ Zona '{name}': {width:.0f}x{height:.0f} @ ({x:.0f}, {y:.0f})")
        return zone
    
    def _update_total_bounds(self, zone: Dict):
        """Aggiorna i bounds totali del layout."""
        minx = min(self.total_bounds[0], zone['x'])
        miny = min(self.total_bounds[1], zone['y'] - zone['height'])
        maxx = max(self.total_bounds[2], zone['x'] + zone['width'])
        maxy = max(self.total_bounds[3], zone['y'])
        self.total_bounds = [minx, miny, maxx, maxy]
    
    def get_total_width(self) -> float:
        return self.total_bounds[2] - self.total_bounds[0]
    
    def get_total_height(self) -> float:
        return self.total_bounds[3] - self.total_bounds[1]


def _calculate_cutting_height_grouped_all(summary: Dict[str, int], customs: List[Dict], placed: List[Dict]) -> float:
    """Calcola altezza necessaria per schema di taglio completo (standard + custom)."""
    
    # Conta tutte le categorie (standard + custom)
    total_categories = 0
    
    # Categorie standard dal summary
    total_categories += len(summary)
    
    # Categorie custom raggruppate per dimensioni
    custom_categories = {}
    for custom in customs:
        width = round(custom['width'])
        height = round(custom['height'])
        key = f"{width}x{height}"
        if key not in custom_categories:
            custom_categories[key] = 1
        else:
            custom_categories[key] += 1
    
    total_categories += len(custom_categories)
    
    # Calcola layout griglia con sezioni pi√π grandi
    sections_per_row = 2  # Ridotto a 2 per dare pi√π spazio
    rows_needed = (total_categories + sections_per_row - 1) // sections_per_row
    
    section_height = 900  # Altezza maggiore per ogni sezione
    title_space = 800     # Spazio per titoli
    margin_between_rows = 150  # Maggior margine tra righe
    
    total_height = title_space + (rows_needed * section_height) + ((rows_needed - 1) * margin_between_rows)
    return max(total_height, 2000)  # Minimo 2000mm per pi√π spazio


def _draw_compact_cartridge(msp, project_name: str, summary: Dict[str, int], 
                          customs: List[Dict], params: Optional[Dict], zone: Dict):
    """Disegna cartiglio compatto nella zona assegnata."""
    offset_x = zone['x']
    offset_y = zone['y']
    
    # Rettangolo cartiglio
    msp.add_lwpolyline([
        (offset_x, offset_y - zone['height']),
        (offset_x + zone['width'], offset_y - zone['height']),
        (offset_x + zone['width'], offset_y),
        (offset_x, offset_y),
        (offset_x, offset_y - zone['height'])
    ], dxfattribs={"layer": "CARTIGLIO"})
    
    # Titolo progetto
    msp.add_text(project_name.upper(), height=100, dxfattribs={
        "layer": "TESTI",
        "style": "Standard"
    }).set_placement((offset_x + zone['width']/2, offset_y - 150),
                    align=TextEntityAlignment.MIDDLE_CENTER)
    
    # Informazioni essenziali
    now = datetime.datetime.now()
    total_standard = sum(summary.values())
    total_custom = len(customs)
    
    # Calcola categorie senza f-string nidificata
    categories_count = len(set(f"{round(c['width'])}x{round(c['height'])}" for c in customs))
    
    info_lines = [
        f"Data: {now.strftime('%d/%m/%Y')}",
        f"Blocchi Std: {total_standard}",
        f"Pezzi Custom: {total_custom}",
        f"Tot Categorie: {categories_count}"
    ]
    
    for i, line in enumerate(info_lines):
        msp.add_text(line, height=60, dxfattribs={
            "layer": "TESTI",
            "style": "Standard"
        }).set_placement((offset_x + 100, offset_y - 300 - i * 100),
                        align=TextEntityAlignment.BOTTOM_LEFT)


def _draw_main_layout(msp, wall_polygon: Polygon, placed: List[Dict], customs: List[Dict], 
                     apertures: Optional[List[Polygon]], zone: Dict, block_config: Optional[Dict] = None):
    """Disegna il layout principale della parete."""
    offset_x = zone['x']
    offset_y = zone['y']
    
    # Contorno parete
    _draw_wall_outline(msp, wall_polygon, offset_x, offset_y)
    
    # Aperture
    if apertures:
        _draw_apertures(msp, apertures, offset_x, offset_y)
    
    # Blocchi
    _draw_standard_blocks(msp, placed, offset_x, offset_y, block_config)
    _draw_custom_blocks(msp, customs, offset_x, offset_y)
    
    # Quote principali
    _add_main_dimensions(msp, wall_polygon, offset_x, offset_y)
    
    # Titolo sezione - SPOSTATO PI√ô IN ALTO
    msp.add_text("LAYOUT PARETE PRINCIPALE", height=300, dxfattribs={
        "layer": "TESTI",
        "style": "Standard"
    }).set_placement((offset_x + zone['width']/2, offset_y + zone['height'] + 800), 
                    align=TextEntityAlignment.MIDDLE_CENTER)


def _draw_cutting_schema_fixed(msp, customs: List[Dict], zone: Dict):
    """Disegna schema di taglio con TUTTI i blocchi (standard + custom) raggruppati per categoria."""
    offset_x = zone['x']
    offset_y = zone['y']
    
    # Titolo sezione
    msp.add_text("SCHEMA DI TAGLIO COMPLETO", height=300, dxfattribs={
        "layer": "TESTI",
        "style": "Standard"
    }).set_placement((offset_x + zone['width']/2, offset_y + zone['height'] + 600), 
                    align=TextEntityAlignment.MIDDLE_CENTER)
    
    msp.add_text("TUTTI I BLOCCHI RAGGRUPPATI PER CATEGORIA", height=200, dxfattribs={
        "layer": "TESTI",
        "style": "Standard"
    }).set_placement((offset_x + zone['width']/2, offset_y + zone['height'] + 300), 
                    align=TextEntityAlignment.MIDDLE_CENTER)
    
    # FORZA la creazione delle categorie con fallback completo
    try:
        from block_grouping import BlockGrouping
        grouping = BlockGrouping()
        
        # Simula dei blocchi standard tipici se non ci sono placed disponibili
        fake_placed = [
            {'width': 1239, 'height': 495},  # Standard A
            {'width': 826, 'height': 495},   # Standard B  
            {'width': 413, 'height': 495}    # Standard C
        ]
        
        # Crea le etichette che popolano automaticamente le categorie
        std_labels, custom_labels = grouping.create_grouped_labels(fake_placed, customs)
        
        # Ora ottieni il riassunto completo
        all_categories = grouping.get_category_summary()
        print(f"üéØ Categorie create: {len(all_categories)}")
        
        # Converte il formato summary in formato compatibile
        category_data = {}
        for category_letter, info in all_categories.items():
            # Trova un blocco rappresentativo
            if info['type'] == 'standard':
                # Crea blocco standard rappresentativo
                dims = info['dimensions'].split('x')
                representative = {
                    'width': int(dims[0]),
                    'height': int(dims[1])
                }
            else:
                # Trova il primo custom di questa categoria
                representative = None
                for i, custom in enumerate(customs):
                    if i in custom_labels and custom_labels[i]['category'] == category_letter:
                        representative = custom
                        break
                if not representative and customs:
                    representative = customs[0]  # Fallback
            
            if representative:
                category_data[category_letter] = {
                    'representative': representative,
                    'count': info['count'],
                    'type': info['type'],
                    'dimensions': info['dimensions']
                }
        
        all_categories = category_data
        
    except Exception as e:
        print(f"‚ùå Errore creazione categorie: {e}")
        # Fallback: raggruppa solo i custom
        all_categories = {}
        for i, custom in enumerate(customs):
            width = round(custom['width'])
            height = round(custom['height'])
            key = f"D"  # Categoria D per custom
            
            if key not in all_categories:
                all_categories[key] = {
                    'representative': custom,
                    'count': 1,
                    'type': 'custom',
                    'dimensions': f"{width}x{height}"
                }
            else:
                all_categories[key]['count'] += 1
    
    if not all_categories:
        msp.add_text("NESSUN BLOCCO DA VISUALIZZARE", height=150, dxfattribs={
            "layer": "TESTI",
            "style": "Standard"
        }).set_placement((offset_x + zone['width']/2, offset_y + zone['height']/2), 
                        align=TextEntityAlignment.MIDDLE_CENTER)
        return
    
    # Resto della logica di disegno schema taglio
    # [... continua con il disegno delle sezioni ...]
    print(f"üéØ Schema taglio con {len(all_categories)} categorie")


def _setup_dxf_layers(doc, color_theme: Optional[Dict] = None):
    """Configura layer professionali con colori personalizzabili."""
    
    # Color mapping da theme a DXF colors
    def theme_color_to_dxf(theme_color, fallback_dxf_color):
        """Converte colore hex del theme in colore DXF."""
        if not theme_color or not isinstance(theme_color, str):
            return fallback_dxf_color
        
        # Mapping semplificato colori comuni
        color_map = {
            '#1E40AF': dxf_colors.BLUE,     # wallOutlineColor default
            '#DC2626': dxf_colors.RED,      # doorWindowBorder default  
            '#374151': dxf_colors.BLACK,    # standardBlockBorder default
            '#7C3AED': dxf_colors.MAGENTA,  # customPieceBorder default
            '#16A34A': dxf_colors.GREEN,    # green variants
        }
        
        return color_map.get(theme_color, fallback_dxf_color)
    
    # Default colors se theme non fornito
    if not color_theme:
        color_theme = {}
    
    layer_config = [
        # (name, theme_key, fallback_color, linetype, lineweight)
        ("PARETE", theme_color_to_dxf(color_theme.get('wallOutlineColor'), dxf_colors.BLUE), "CONTINUOUS", 0.50),
        ("APERTURE", theme_color_to_dxf(color_theme.get('doorWindowBorder'), dxf_colors.RED), "DASHED", 0.30),
        ("BLOCCHI_STD", theme_color_to_dxf(color_theme.get('standardBlockBorder'), dxf_colors.BLACK), "CONTINUOUS", 0.25),
        ("BLOCCHI_CUSTOM", theme_color_to_dxf(color_theme.get('customPieceBorder'), dxf_colors.MAGENTA), "CONTINUOUS", 0.35),
        ("QUOTE", dxf_colors.MAGENTA, "CONTINUOUS", 0.18),
        ("TESTI", dxf_colors.BLACK, "CONTINUOUS", 0.15),
        ("TAGLIO", dxf_colors.CYAN, "CONTINUOUS", 0.40),
        ("CARTIGLIO", dxf_colors.BLACK, "CONTINUOUS", 0.25),
        ("LEGENDA", dxf_colors.BLACK, "CONTINUOUS", 0.20),
    ]
    
    print(f"üé® [DEBUG] Setting up DXF layers with theme colors: {color_theme}")
    
    for name, color, linetype, lineweight in layer_config:
        layer = doc.layers.add(name)
        layer.color = color
        layer.linetype = linetype
        layer.lineweight = int(lineweight * 100)  # Convert to AutoCAD units


def _draw_wall_outline(msp, wall_polygon: Polygon, offset_x: float, offset_y: float):
    """Disegna il contorno della parete principale."""
    # Contorno esterno con linea pi√π spessa
    exterior_coords = [(x + offset_x, y + offset_y) for x, y in wall_polygon.exterior.coords]
    msp.add_lwpolyline(exterior_coords, close=True, dxfattribs={
        "layer": "PARETE",
        "lineweight": 100  # Linea pi√π spessa per visibilit√†
    })
    
    # Contorni interni (holes)
    for interior in wall_polygon.interiors:
        interior_coords = [(x + offset_x, y + offset_y) for x, y in interior.coords]
        msp.add_lwpolyline(interior_coords, close=True, dxfattribs={
            "layer": "PARETE",
            "lineweight": 80
        })


def _draw_apertures(msp, apertures: List[Polygon], offset_x: float, offset_y: float):
    """Disegna porte e finestre."""
    for i, aperture in enumerate(apertures):
        coords = [(x + offset_x, y + offset_y) for x, y in aperture.exterior.coords]
        msp.add_lwpolyline(coords, close=True, dxfattribs={"layer": "APERTURE"})
        
        # Etichetta apertura
        minx, miny, maxx, maxy = aperture.bounds
        center_x = (minx + maxx) / 2 + offset_x
        center_y = (miny + maxy) / 2 + offset_y
        width = maxx - minx
        height = maxy - miny
        
        label = f"AP{i+1}\n{width:.0f}x{height:.0f}"
        msp.add_text(label, height=150, dxfattribs={
            "layer": "TESTI", 
            "style": "Standard"
        }).set_placement((center_x, center_y), align=TextEntityAlignment.MIDDLE_CENTER)


def _draw_standard_blocks(msp, placed: List[Dict], offset_x: float, offset_y: float, block_config: Optional[Dict] = None):
    """Disegna blocchi standard con etichette raggruppate."""
    # Usa il sistema di etichettatura avanzato con mapping personalizzato
    if block_config and block_config.get('size_to_letter'):
        print(f"üé® [DEBUG] DXF using custom size_to_letter: {block_config.get('size_to_letter')}")
        detailed_labels, _ = create_detailed_block_labels(placed, [], block_config.get('size_to_letter'))
    else:
        print(f"üé® [DEBUG] DXF using default system")
        detailed_labels, _ = create_detailed_block_labels(placed, [])
    
    for i, block in enumerate(placed):
        x1 = block['x'] + offset_x
        y1 = block['y'] + offset_y
        x2 = x1 + block['width']
        y2 = y1 + block['height']
        
        # Rettangolo blocco
        msp.add_lwpolyline([
            (x1, y1), (x2, y1), (x2, y2), (x1, y2), (x1, y1)
        ], dxfattribs={"layer": "BLOCCHI_STD"})
        
        # Sistema di etichettatura NUOVO: categoria BL + numero TR
        if i in detailed_labels:
            label_info = detailed_labels[i]
            
            # Posizioni specifiche
            category_x = x1 + 50  # Basso sinistra X
            category_y = y1 + 50  # Basso sinistra Y
            number_x = x2 - 50    # Alto destra X  
            number_y = y2 - 50    # Alto destra Y
            
            # Lettera categoria (basso sinistra) - pi√π grande
            category = label_info['display']['bottom_left']
            msp.add_text(category, height=150, dxfattribs={
                "layer": "TESTI",
                "style": "Standard",
                "color": 1  # Rosso per categoria
            }).set_placement((category_x, category_y), align=TextEntityAlignment.BOTTOM_LEFT)
            
            # Numero progressivo (alto destra) - pi√π piccolo
            number = label_info['display']['top_right']
            msp.add_text(number, height=100, dxfattribs={
                "layer": "TESTI", 
                "style": "Standard",
                "color": 2  # Giallo per numero
            }).set_placement((number_x, number_y), align=TextEntityAlignment.TOP_RIGHT)
            
        else:
            # Fallback: etichetta centrata con mapping personalizzato se disponibile
            center_x = x1 + block['width'] / 2
            center_y = y1 + block['height'] / 2
            
            if block_config and block_config.get('size_to_letter'):
                std_labels_detailed, _ = create_detailed_block_labels(placed, [], block_config.get('size_to_letter'))
                std_labels = {i: label['full_label'] for i, label in std_labels_detailed.items()}
            else:
                std_labels, _ = create_block_labels(placed, [])
            label = std_labels.get(i, f"STD{i+1}")
            
            msp.add_text(label, height=120, dxfattribs={
                "layer": "TESTI",
                "style": "Standard"
            }).set_placement((center_x, center_y), align=TextEntityAlignment.MIDDLE_CENTER)


def _draw_custom_blocks(msp, customs: List[Dict], offset_x: float, offset_y: float):
    """Disegna blocchi custom con etichette raggruppate e info taglio."""
    # Usa il nuovo sistema di etichettatura dettagliata
    _, detailed_labels = create_detailed_block_labels([], customs)
    
    for i, custom in enumerate(customs):
        # Disegna geometria custom
        try:
            poly = shape(custom['geometry'])
            coords = [(x + offset_x, y + offset_y) for x, y in poly.exterior.coords]
            msp.add_lwpolyline(coords, close=True, dxfattribs={"layer": "BLOCCHI_CUSTOM"})
            
            # Calcola bounds per posizionamento etichette
            x1 = custom['x'] + offset_x
            y1 = custom['y'] + offset_y
            x2 = x1 + custom['width']
            y2 = y1 + custom['height']
            
            # Sistema di etichettatura NUOVO: categoria BL + numero TR
            if i in detailed_labels:
                label_info = detailed_labels[i]
                
                # Posizioni specifiche
                category_x = x1 + 40  # Basso sinistra X (margine pi√π piccolo per custom)
                category_y = y1 + 40  # Basso sinistra Y
                number_x = x2 - 40    # Alto destra X  
                number_y = y2 - 40    # Alto destra Y
                
                # Lettera categoria (basso sinistra) - pi√π grande
                category = label_info['display']['bottom_left']
                msp.add_text(category, height=120, dxfattribs={
                    "layer": "TESTI",
                    "style": "Standard",
                    "color": 3  # Verde per categoria custom
                }).set_placement((category_x, category_y), align=TextEntityAlignment.BOTTOM_LEFT)
                
                # Numero progressivo (alto destra) - pi√π piccolo
                number = label_info['display']['top_right']
                msp.add_text(number, height=80, dxfattribs={
                    "layer": "TESTI", 
                    "style": "Standard",
                    "color": 4  # Cyan per numero custom
                }).set_placement((number_x, number_y), align=TextEntityAlignment.TOP_RIGHT)
                
                # Info taglio al centro (opzionale, pi√π piccola)
                center_x = custom['x'] + custom['width'] / 2 + offset_x
                center_y = custom['y'] + custom['height'] / 2 + offset_y
                
                ctype = custom.get('ctype', 2)
                dimensions_text = f"{custom['width']:.0f}x{custom['height']:.0f}\nCU{ctype}"
                
                msp.add_text(dimensions_text, height=60, dxfattribs={
                    "layer": "TESTI",
                    "style": "Standard",
                    "color": 8  # Grigio per info aggiuntive
                }).set_placement((center_x, center_y), align=TextEntityAlignment.MIDDLE_CENTER)
                
            else:
                # Fallback: etichetta centrata legacy
                center_x = custom['x'] + custom['width'] / 2 + offset_x
                center_y = custom['y'] + custom['height'] / 2 + offset_y
                
                _, custom_labels = create_block_labels([], customs)
                label = custom_labels.get(i, f"CU{i+1}")
                
                ctype = custom.get('ctype', 2)
                full_label = f"{label}\n{custom['width']:.0f}x{custom['height']:.0f}\nCU{ctype}"
                
                msp.add_text(full_label, height=90, dxfattribs={
                    "layer": "TESTI",
                    "style": "Standard"
                }).set_placement((center_x, center_y), align=TextEntityAlignment.MIDDLE_CENTER)
            
        except Exception as e:
            print(f"‚ùå Errore disegno custom {i}: {e}")


def _add_main_dimensions(msp, wall_polygon: Polygon, offset_x: float, offset_y: float):
    """Aggiunge quote principali della parete."""
    minx, miny, maxx, maxy = wall_polygon.bounds
    wall_width = maxx - minx
    wall_height = maxy - miny
    
    # Quota larghezza totale (in basso)
    dim_y = miny + offset_y - 300
    dim = msp.add_linear_dim(
        base=(minx + offset_x, dim_y),
        p1=(minx + offset_x, miny + offset_y),
        p2=(maxx + offset_x, miny + offset_y),
        text=f"{wall_width:.0f}",
        dimstyle="Standard",
        dxfattribs={"layer": "QUOTE"}
    )
    
    # Quota altezza totale (a sinistra)
    dim_x = minx + offset_x - 300
    dim = msp.add_linear_dim(
        base=(dim_x, miny + offset_y),
        p1=(minx + offset_x, miny + offset_y),
        p2=(minx + offset_x, maxy + offset_y),
        text=f"{wall_height:.0f}",
        dimstyle="Standard",
        dxfattribs={"layer": "QUOTE"}
    )